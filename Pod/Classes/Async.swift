//
//  Async.swift
//  AsyncDemo
//
//  Created by Zhixuan Lai on 2/24/16.
//  Copyright Â© 2016 Zhixuan Lai. All rights reserved.
//

import Foundation

// MARK: - Default
// MARK: async/await
public func async(queue: dispatch_queue_t = getDefaultQueue(), block: () -> Void) -> ((Void -> Void) -> Void) {
    return {(callback: Void -> Void) in
        dispatch_async(queue) {
            block()
            callback()
        }
    }
}

/*:
https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5
The actual number of tasks executed by a concurrent queue at any given moment is variable and can change dynamically as conditions in your application change. Many factors affect the number of tasks executed by the concurrent queues, including the number of available cores, the amount of work being done by other processes, and the number and priority of tasks in other serial dispatch queues.
*/
public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), parallel blocks: [((Void -> Void) -> Void)]) {
    let group = dispatch_group_create()

    for block in blocks {
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {
                dispatch_semaphore_signal(fd_sema)
            }
            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)
}

public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: ((Void -> Void) -> Void)) {
    return await(queue, parallel: [block])
}

// MARK: async/await { }

public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: Void -> ((Void -> Void) -> Void)) {
    return await(parallel: [block()])[0]
}


// MARK: async<T>/await<T>

public func async<T>(queue: dispatch_queue_t = getDefaultQueue(), block: () -> T) -> ((T -> Void) -> Void) {
    return {(callback: T -> Void) in
        dispatch_async(queue) {
            callback(block())
        }
    }
}

public func await<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), parallel blocks: [K: (T -> Void) -> Void]) -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    for (index, block) in blocks {
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {(result: T) in
                results[index] = result
                dispatch_semaphore_signal(fd_sema)
            }
            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    return results
}

public func await<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), parallel blocks: [(T -> Void) -> Void]) -> [T] {
    let dictBlocks = blocks.indexedDictionary
    let results = await(queue, timeout: timeout, parallel: dictBlocks)
    return Array(results.values)
}

public func await<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: (T -> Void) -> Void) -> T {
    return await(queue, timeout: timeout, parallel: [block])[0]
}

public func await<T>(timeout: dispatch_time_t, block: (T -> Void) -> Void) -> T {
    return await(timeout: timeout, parallel: [block])[0]
}

public func await<T>(queue: dispatch_queue_t, block: (T -> Void) -> Void) -> T {
    return await(queue, parallel: [block])[0]
}

public func await<T>(block: (T -> Void) -> Void) -> T {
    return await(parallel: [block])[0]
}

// MARK: async<T>/await<T> { }

public func await<T>(block: (Void -> (T -> Void) -> Void)) -> T {
    return await(parallel: [block()])[0]
}

// queue, timeout

// MARK: - Error Handling

/*:
https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/
> GCD is a C level API; it does not catch exceptions generated by higher level languages. Your application must catch all exceptions before returning from a block submitted to a dispatch queue.
*/

// MARK: async$/await$
public func async$(queue: dispatch_queue_t = getDefaultQueue(), block: () throws -> Void) -> ((ErrorType? -> Void) -> Void) {
    return {callback in
        dispatch_async(queue) {
            do {
                try block()
                callback(nil)
            } catch {
                callback(error)
            }
        }
    }
}

public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), parallel blocks: [((ErrorType? -> Void) -> Void)]) throws {
    let group = dispatch_group_create()

    var err: ErrorType?

    for block in blocks {
        guard err == nil else { break }

        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {error in
                err = error
                dispatch_semaphore_signal(fd_sema)
            }

            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    if let err = err {
        throw err
    }
}


public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: ((ErrorType? -> Void) -> Void)) throws {
    return try await$(queue, parallel: [block])
}


// MARK: async$/await$ { }
public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: Void -> ((ErrorType? -> Void) -> Void)) throws {
    return try await$(queue, block: block())
}


// MARK: async$<T>/await$<T>
public func async$<T>(queue: dispatch_queue_t = getDefaultQueue(), block: () throws -> T) -> (((T?, ErrorType?) -> Void) -> Void) {
    return {(callback: (T?, ErrorType?) -> Void) in
        dispatch_async(queue) {
            do {
                callback(try block(), nil)
            } catch {
                callback(nil, error)
            }
        }
    }
}

public func await$<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), parallel blocks: [K: (((T?, ErrorType?) -> Void) -> Void)]) throws -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    var err: ErrorType?

    for (key, block) in blocks {
        guard err == nil else { break }
        
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)

            block {result, error in
                results[key] = result
                err = error
                dispatch_semaphore_signal(fd_sema)
            }

            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    if let err = err {
        throw err
    }
    
    return results
}

public func await$<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), parallel blocks: [(((T?, ErrorType?) -> Void) -> Void)]) throws -> [T] {
    let dictBlocks = blocks.indexedDictionary
    return Array(try await$(queue, timeout: timeout, parallel: dictBlocks).values)
}

public func await$<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(queue, timeout: timeout, parallel: [block])[0]
}

public func await$<T>(timeout: dispatch_time_t, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(timeout: timeout, parallel: [block])[0]
}

public func await$<T>(queue: dispatch_queue_t, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(queue, parallel: [block])[0]
}

public func await$<T>(block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(parallel: [block])[0]
}

// MARK: async$<T>/await$<T> { }
public func await$<T>(block: (Void -> (((T?, ErrorType?) -> Void) -> Void))) throws -> T {
    return try await$(parallel: [block()])[0]
}

// TODO: queue, timeout


/*
public func await<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: Void -> ((T -> Void) -> Void)) -> T {
return await(queue, timeout: timeout, block: block())
}

*/

// MARK: - Helpers
private func getDefaultQueue() -> dispatch_queue_t {
    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
}

private func getDefaultTimeout() -> dispatch_time_t {
    return DISPATCH_TIME_FOREVER
}

private extension Array {
    var indexedDictionary: [Int:Element] {
        var result: [Int:Element] = [:]
        for (index, element) in enumerate() {
            result[index] = element
        }
        return result
    }
}

