//
//  Async.swift
//  AsyncDemo
//
//  Created by Zhixuan Lai on 2/24/16.
//  Copyright Â© 2016 Zhixuan Lai. All rights reserved.
//

import Foundation

/*:
https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/
> GCD is a C level API; it does not catch exceptions generated by higher level languages. Your application must catch all exceptions before returning from a block submitted to a dispatch queue.
*/

public func async(queue: dispatch_queue_t = getDefaultQueue(), block: () -> Void) -> (Void -> Void) {
    return {
        dispatch_async(queue) {
            block()
        }
    }
}


public func async<T>(queue: dispatch_queue_t = getDefaultQueue(), block: () -> T) -> ((T -> Void) -> Void) {
    return {(callback: T -> Void) in
        dispatch_async(queue) {
            callback(block())
        }
    }
}


public func await<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [K: (T -> Void) -> Void]) -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    for (index, block) in blocks {
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {(result: T) in
                results[index] = result
                dispatch_semaphore_signal(fd_sema)
            }
            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    return results
}

public func await<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [(T -> Void) -> Void]) -> [T] {
    let dictBlocks = blocks.indexedDictionary
    return Array(await(queue, timeout: timeout, blocks: dictBlocks).values)
}

public func await<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: (T -> Void) -> Void) -> T {
    return await(queue, timeout: timeout, blocks: [block])[0]
}

public func await<T>(timeout: dispatch_time_t, block: (T -> Void) -> Void) -> T {
    return await(timeout: timeout, blocks: [block])[0]
}

public func await<T>(queue: dispatch_queue_t, block: (T -> Void) -> Void) -> T {
    return await(queue, blocks: [block])[0]
}

public func await<T>(block: (T -> Void) -> Void) -> T {
    return await(blocks: [block])[0]
}

// await empty async
public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [() -> ()]) {
    let group = dispatch_group_create()

    for block in blocks {
        dispatch_group_async(group, queue) {
            block()
        }
    }

    dispatch_group_wait(group, timeout)
}

public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: () -> ()) {
    return await(queue, blocks: [block])
}


// { }
public func await<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: Void -> [K: (T -> Void) -> Void]) -> [K: T] {
    return await(queue, timeout: timeout, blocks: blocks())
}

public func await<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: Void -> [(T -> Void) -> Void]) -> [T] {
    return await(queue, timeout: timeout, blocks: blocks())
}

// queue, timeout

public func await<T>(block: (Void -> (T -> Void) -> Void)) -> T {
    return await(blocks: [block()])[0]
}



// With errro handling

public func async$(queue: dispatch_queue_t = getDefaultQueue(), block: () throws -> Void) -> (Void throws -> Void) {
    return {
        var err: ErrorType?
        dispatch_async(queue) {
            do {
                try block()
            } catch {
                err = error
            }
        }
        if let err = err {
            throw err
        }
    }
}

public func async$<T>(queue: dispatch_queue_t = getDefaultQueue(), block: () throws -> T) -> ((T -> Void) throws -> Void) {
    return {(callback: T -> Void) in
        var err: ErrorType?
        dispatch_async(queue) {
            do {
                try callback(block())
            } catch {
                err = error
            }
        }
        if let err = err {
            throw err
        }
    }
}


public func await$<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [K: (T -> Void) throws -> Void]) throws -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    var err: ErrorType?

    for (index, block) in blocks {
        guard err == nil else { break }
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            do {
                try block {(result: T) in
                    results[index] = result
                    dispatch_semaphore_signal(fd_sema)
                }
            } catch {
                err = error
            }

            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    if let err = err {
        throw err
    }
    
    return results
}

public func await$<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [(T -> Void) throws -> Void]) throws -> [T] {
    let dictBlocks = blocks.indexedDictionary
    return Array(try await$(queue, timeout: timeout, blocks: dictBlocks).values)
}

public func await$<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: (T -> Void) throws -> Void) throws -> T {
    return try await$(queue, timeout: timeout, blocks: [block])[0]
}

public func await$<T>(timeout: dispatch_time_t, block: (T -> Void) throws -> Void) throws -> T {
    return try await$(timeout: timeout, blocks: [block])[0]
}

public func await$<T>(queue: dispatch_queue_t, block: (T -> Void) throws -> Void) throws -> T {
    return try await$(queue, blocks: [block])[0]
}

public func await$<T>(block: (T -> Void) throws -> Void) throws -> T {
    return try await$(blocks: [block])[0]
}


// await empty async
public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [() throws -> ()]) throws {
    let group = dispatch_group_create()

    var err: ErrorType?

    for block in blocks {
        guard err == nil else { break }

        dispatch_group_async(group, queue) {
            do {
                print("before error")
                try block()
                print("no error")
            } catch {
                print("here \(error)")
                err = error
            }
        }
    }

    dispatch_group_wait(group, timeout)

    print("here2 \(err)")

    if let err = err {
        throw err
    }
}

public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: () throws -> ()) throws {
    return try await$(queue, blocks: [block])
}




// { }
public func await$<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: Void -> [K: (T -> Void) throws -> Void]) throws -> [K: T] {
    return try await$(queue, timeout: timeout, blocks: blocks())
}

public func await$<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: Void -> [(T -> Void) throws -> Void]) throws -> [T] {
    return try await$(queue, timeout: timeout, blocks: blocks())
}

// queue, timeout

public func await$<T>(block: (Void -> (T -> Void) throws -> Void)) throws -> T {
    return try await$(blocks: [block()])[0]
}

public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: (Void -> () throws -> ())) throws {
    return try await$(queue, blocks: [block()])
}



/*
public func await<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: Void -> ((T -> Void) -> Void)) -> T {
return await(queue, timeout: timeout, block: block())
}

*/

// MARK: - Helpers
private func getDefaultQueue() -> dispatch_queue_t {
    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
}

private func getDefaultTimeout() -> dispatch_time_t {
    return DISPATCH_TIME_FOREVER
}

private extension Array {
    var indexedDictionary: [Int:Element] {
        var result: [Int:Element] = [:]
        for (index, element) in enumerate() {
            result[index] = element
        }
        return result
    }
}

