//
//  Async.swift
//  AsyncDemo
//
//  Created by Zhixuan Lai on 2/24/16.
//  Copyright Â© 2016 Zhixuan Lai. All rights reserved.
//

import Foundation

// MARK: - Default
// MARK: async/await
public func async(queue: dispatch_queue_t = getDefaultQueue(), block: () -> Void) -> ((Void -> Void) -> Void) {
    return {(callback: Void -> Void) in
        dispatch_async(queue) {
            block()
            callback()
        }
    }
}

public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [((Void -> Void) -> Void)]) {
    let group = dispatch_group_create()

    for block in blocks {
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {
                dispatch_semaphore_signal(fd_sema)
            }
            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)
}

public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: ((Void -> Void) -> Void)) {
    return await(queue, blocks: [block])
}

// MARK: async/await { }

public func await(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: Void -> ((Void -> Void) -> Void)) {
    return await(blocks: [block()])[0]
}


// MARK: async<T>/await<T>

public func async<T>(queue: dispatch_queue_t = getDefaultQueue(), block: () -> T) -> ((T -> Void) -> Void) {
    return {(callback: T -> Void) in
        dispatch_async(queue) {
            callback(block())
        }
    }
}

public func await<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [K: (T -> Void) -> Void]) -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    for (index, block) in blocks {
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {(result: T) in
                results[index] = result
                dispatch_semaphore_signal(fd_sema)
            }
            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    return results
}

public func await<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [(T -> Void) -> Void]) -> [T] {
    let dictBlocks = blocks.indexedDictionary
    let results = await(queue, timeout: timeout, blocks: dictBlocks)
    return Array(results.values)
}

public func await<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: (T -> Void) -> Void) -> T {
    return await(queue, timeout: timeout, blocks: [block])[0]
}

public func await<T>(timeout: dispatch_time_t, block: (T -> Void) -> Void) -> T {
    return await(timeout: timeout, blocks: [block])[0]
}

public func await<T>(queue: dispatch_queue_t, block: (T -> Void) -> Void) -> T {
    return await(queue, blocks: [block])[0]
}

public func await<T>(block: (T -> Void) -> Void) -> T {
    return await(blocks: [block])[0]
}

// MARK: async<T>/await<T> { }

public func await<T>(block: (Void -> (T -> Void) -> Void)) -> T {
    return await(blocks: [block()])[0]
}

// queue, timeout

// MARK: - Error Handling

/*:
https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/
> GCD is a C level API; it does not catch exceptions generated by higher level languages. Your application must catch all exceptions before returning from a block submitted to a dispatch queue.
*/

// MARK: async$/await$
public func async$(queue: dispatch_queue_t = getDefaultQueue(), block: () throws -> Void) -> ((ErrorType? -> Void) -> Void) {
    return {callback in
        dispatch_async(queue) {
            do {
                try block()
                callback(nil)
            } catch {
                callback(error)
            }
        }
    }
}

public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [((ErrorType? -> Void) -> Void)]) throws {
    let group = dispatch_group_create()

    var err: ErrorType?

    for block in blocks {
        guard err == nil else { break }

        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)
            block {error in
                err = error
                dispatch_semaphore_signal(fd_sema)
            }

            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    if let err = err {
        throw err
    }
}


public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: ((ErrorType? -> Void) -> Void)) throws {
    return try await$(queue, blocks: [block])
}


// MARK: async$/await$ { }
public func await$(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), block: Void -> ((ErrorType? -> Void) -> Void)) throws {
    return try await$(queue, block: block())
}


// MARK: async$<T>/await$<T>
public func async$<T>(queue: dispatch_queue_t = getDefaultQueue(), block: () throws -> T) -> (((T?, ErrorType?) -> Void) -> Void) {
    return {(callback: (T?, ErrorType?) -> Void) in
        dispatch_async(queue) {
            do {
                callback(try block(), nil)
            } catch {
                callback(nil, error)
            }
        }
    }
}

public func await$<K, T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [K: (((T?, ErrorType?) -> Void) -> Void)]) throws -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    var err: ErrorType?

    for (key, block) in blocks {
        guard err == nil else { break }
        
        dispatch_group_async(group, queue) {
            let fd_sema = dispatch_semaphore_create(0)

            block {result, error in
                results[key] = result
                err = error
                dispatch_semaphore_signal(fd_sema)
            }

            dispatch_semaphore_wait(fd_sema, timeout)
        }
    }

    dispatch_group_wait(group, timeout)

    if let err = err {
        throw err
    }
    
    return results
}

public func await$<T>(queue: dispatch_queue_t = getDefaultQueue(), timeout: dispatch_time_t = getDefaultTimeout(), blocks: [(((T?, ErrorType?) -> Void) -> Void)]) throws -> [T] {
    let dictBlocks = blocks.indexedDictionary
    return Array(try await$(queue, timeout: timeout, blocks: dictBlocks).values)
}

public func await$<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(queue, timeout: timeout, blocks: [block])[0]
}

public func await$<T>(timeout: dispatch_time_t, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(timeout: timeout, blocks: [block])[0]
}

public func await$<T>(queue: dispatch_queue_t, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(queue, blocks: [block])[0]
}

public func await$<T>(block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(blocks: [block])[0]
}

// MARK: async$<T>/await$<T> { }
public func await$<T>(block: (Void -> (((T?, ErrorType?) -> Void) -> Void))) throws -> T {
    return try await$(blocks: [block()])[0]
}

// TODO: queue, timeout


/*
public func await<T>(queue: dispatch_queue_t, timeout: dispatch_time_t, block: Void -> ((T -> Void) -> Void)) -> T {
return await(queue, timeout: timeout, block: block())
}

*/

// MARK: - Helpers
private func getDefaultQueue() -> dispatch_queue_t {
    return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
}

private func getDefaultTimeout() -> dispatch_time_t {
    return DISPATCH_TIME_FOREVER
}

private extension Array {
    var indexedDictionary: [Int:Element] {
        var result: [Int:Element] = [:]
        for (index, element) in enumerate() {
            result[index] = element
        }
        return result
    }
}

