//
//  Async.swift
//  AsyncDemo
//
//  Created by Zhixuan Lai on 2/24/16.
//  Copyright Â© 2016 Zhixuan Lai. All rights reserved.
//

import Foundation

// MARK: - Default

// MARK: async<T>/await<T>

public func async<T>(queue: DispatchQueue = getDefaultQueue(), block: () -> T) -> ((T -> Void) -> Void) {
    return {(callback: T -> Void) in
        dispatch_async(queue.get()) {
            callback(block())
        }
    }
}

public func await<K, T>(queue: DispatchQueue = getDefaultQueue(), parallel blocks: [K: (T -> Void) -> Void]) -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    for (index, block) in blocks {
        dispatch_group_async(group, queue.get()) {
            let fd_sema = dispatch_semaphore_create(0)
            block {(result: T) in
                results[index] = result
                dispatch_semaphore_signal(fd_sema)
            }
            dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER)
        }
    }

    dispatch_group_wait(group, DISPATCH_TIME_FOREVER)

    return results
}

public func await<T>(queue: DispatchQueue = getDefaultQueue(), parallel blocks: [(T -> Void) -> Void]) -> [T] {
    let dictBlocks = blocks.indexedDictionary
    let results = await(queue, parallel: dictBlocks)
    return Array(results.values)
}

// TODO queue default value?
public func await<T>(queue: DispatchQueue = getDefaultQueue(), block: (T -> Void) -> Void) -> T {
    return await(queue, parallel: [block])[0]
}

public func await<T>(block: (T -> Void) -> Void) -> T {
    return await(parallel: [block])[0]
}


// MARK: async<T>/await<T> { }

public func await<T>(block: (Void -> (T -> Void) -> Void)) -> T {
    return await(parallel: [block()])[0]
}


// queue, timeout

// MARK: async<T>/await<T> timeout

/*:
https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW5
The actual number of tasks executed by a concurrent queue at any given moment is variable and can change dynamically as conditions in your application change. Many factors affect the number of tasks executed by the concurrent queues, including the number of available cores, the amount of work being done by other processes, and the number and priority of tasks in other serial dispatch queues.
*/

//public func await(queue: DispatchQueue = getDefaultQueue(), timeout: dispatch_time_t, parallel blocks: [((Void -> Void) -> Void)]) -> [Bool] {
//    let group = dispatch_group_create()
//
//    var timeouts = [Bool](count: blocks.count, repeatedValue: true)
//    for (index, block) in blocks.enumerate() {
//        dispatch_group_async(group, queue.get()) {
//            let fd_sema = dispatch_semaphore_create(0)
//            block {
//                dispatch_semaphore_signal(fd_sema)
//            }
//            timeouts[index] = dispatch_semaphore_wait(fd_sema, timeout) == 1
//        }
//    }
//
//    // useful?
//    let timeoutOccured = dispatch_group_wait(group, timeout)
//    return timeouts
//}

// MARK: - Error Handling

/*:
https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/
> GCD is a C level API; it does not catch exceptions generated by higher level languages. Your application must catch all exceptions before returning from a block submitted to a dispatch queue.
*/

// MARK: async$<T>/await$<T>
public func async$<T>(queue: DispatchQueue = getDefaultQueue(), block: () throws -> T) -> (((T?, ErrorType?) -> Void) -> Void) {
    return {(callback: (T?, ErrorType?) -> Void) in
        dispatch_async(queue.get()) {
            do {
                callback(try block(), nil)
            } catch {
                callback(nil, error)
            }
        }
    }
}

public func await$<K, T>(queue: DispatchQueue = getDefaultQueue(), parallel blocks: [K: (((T?, ErrorType?) -> Void) -> Void)]) throws -> [K: T] {
    let group = dispatch_group_create()

    var results = [K: T]()

    var err: ErrorType?

    for (key, block) in blocks {
        guard err == nil else { break }
        
        dispatch_group_async(group, queue.get()) {
            let fd_sema = dispatch_semaphore_create(0)

            block {result, error in
                results[key] = result
                err = error
                dispatch_semaphore_signal(fd_sema)
            }

            dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER)
        }
    }

    dispatch_group_wait(group, DISPATCH_TIME_FOREVER)

    if let err = err {
        throw err
    }
    
    return results
}

public func await$<T>(queue: DispatchQueue = getDefaultQueue(), parallel blocks: [(((T?, ErrorType?) -> Void) -> Void)]) throws -> [T] {
    let dictBlocks = blocks.indexedDictionary
    return Array(try await$(queue, parallel: dictBlocks).values)
}

public func await$<T>(queue: DispatchQueue, block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(queue, parallel: [block])[0]
}

public func await$<T>(block: (((T?, ErrorType?) -> Void) -> Void)) throws -> T {
    return try await$(parallel: [block])[0]
}

// MARK: async$<T>/await$<T> { }
public func await$<T>(block: (Void -> (((T?, ErrorType?) -> Void) -> Void))) throws -> T {
    return try await$(parallel: [block()])[0]
}

// TODO: queue, timeout


/*
public func await<T>(queue: DispatchQueue, timeout: dispatch_time_t, block: Void -> ((T -> Void) -> Void)) -> T {
return await(queue, timeout: timeout, block: block())
}

*/

// MARK: - Helpers
private func getDefaultQueue() -> DispatchQueue {
    return .UserInitiated
}

private extension Array {
    var indexedDictionary: [Int:Element] {
        var result: [Int:Element] = [:]
        for (index, element) in enumerate() {
            result[index] = element
        }
        return result
    }
}

